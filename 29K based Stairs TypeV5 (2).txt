-- CONFIGURA√á√ÉO Rad
local P1000ToggleKey = "H"         -- tecla para ativar/desativar
local basePosX = -282
local basePosZ = -68
local dESYNCCENTRALPOSITION = 170
local spoofRadius = 1e+37 -- Valor padr√£o, pode ser alterado pela TextBox

-- SERVI√áOS
local Players     = game:GetService("Players")
local RunService  = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Mouse       = LocalPlayer:GetMouse()

-- VARI√ÅVEIS
local enabled     = false
local DesyncState = { CFrame = nil, Velocity = nil }
local tabuaPart = nil
local escadaParts = {}
local ultimoMinHeight = nil

local function RandomNumberRange(a)
return math.random(-a * 100, a * 100) / 100
end

local function GetBall()
for _, Ball in ipairs(workspace.Balls:GetChildren()) do
if Ball:GetAttribute("realBall") == true then
return Ball
end
end
end

local function criarEscada()
local degraus = 300
local raio = 6.5
local lateralShift = -6.8
local angulo = 98.5
local anguloIncremento = 9

for i = 1, degraus do  
    local degrau = Instance.new("Part")  
    degrau.Anchored = true  
    degrau.CastShadow = false  
    degrau.Size = Vector3.new(8, 0.5, 1)  
    degrau.Material = Enum.Material.WoodPlanks  
    degrau.Color = Color3.fromRGB(180, 140, 100)  
    degrau.Name = "DesyncEscadaPart"  
    degrau.Parent = workspace  
    table.insert(escadaParts, degrau)  
end

end

local function criarTabua()
tabuaPart = Instance.new("Part")
tabuaPart.Anchored = true
tabuaPart.CastShadow = false
tabuaPart.Size = Vector3.new(12, 1, 12)
tabuaPart.Material = Enum.Material.Metal
tabuaPart.Color = Color3.fromRGB(200, 200, 200)
tabuaPart.Name = "DesyncTabua"
tabuaPart.Parent = workspace
end

local function moverTabuaEescada(minHeight)
if not tabuaPart then criarTabua() end
if #escadaParts == 0 then criarEscada() end

local alturaTabua = minHeight + dESYNCCENTRALPOSITION  
tabuaPart.Position = Vector3.new(basePosX, alturaTabua, basePosZ)  

local posTabua = Vector3.new(basePosX, alturaTabua, basePosZ)  
local degraus = #escadaParts  
local raio = 6.5  
local lateralShift = -6.8  
local alturaBase = minHeight - 10  
local basePos = Vector3.new(posTabua.X + lateralShift, alturaBase, posTabua.Z + 6.5)  
local alturaDegrau = (alturaTabua - basePos.Y) / degraus  

local angulo = 98.5  
local anguloIncremento = 9  

for i, degrau in ipairs(escadaParts) do  
    local rad = math.rad(angulo)  
    local x = math.cos(rad) * raio  
    local z = math.sin(rad) * raio  
    local y = basePos.Y + (i - 1) * alturaDegrau  

    degrau.Position = Vector3.new(basePos.X + x, y, basePos.Z + z)  
    degrau.Orientation = Vector3.new(0, -angulo, 0)  

    angulo = angulo + anguloIncremento  
end

end

RunService.RenderStepped:Connect(function()
if not enabled then return end

-- Procura por "BALLSPAWN" dentro de qualquer filho de workspace.Map  
local ballSpawn  
local map = workspace:FindFirstChild("Map")  
if map then  
	for _, descendant in pairs(map:GetDescendants()) do  
		if descendant:IsA("BasePart") and descendant.Name == "BALLSPAWN" then  
			ballSpawn = descendant  
			break  
		end  
	end  
end  

-- Se achou o BALLSPAWN, atualiza X e Z do ponto de desync  
if ballSpawn then  
	basePosX = ballSpawn.Position.X  
	basePosZ = ballSpawn.Position.Z  
end

end)

local function removerTabuaEescada()
if tabuaPart then
tabuaPart:Destroy()
tabuaPart = nil
end
for _, p in ipairs(escadaParts) do
if p and p:IsDescendantOf(workspace) then
p:Destroy()
end
end
escadaParts = {}
end

-- Ativa√ß√£o/desativa√ß√£o
Mouse.KeyDown:Connect(function(key)
key = string.lower(key)
if key == string.lower(P1000ToggleKey) then
local ball = GetBall()
if not ball then
warn("‚ö†Ô∏è Desync cancelado: Bola real n√£o encontrada.")
return
end

enabled = not enabled  

    if enabled then  
        print("‚úÖ Desync ativado!")  
        ultimoMinHeight = ball:GetAttribute("minHeight") or ball.Position.Y  
        moverTabuaEescada(ultimoMinHeight)  
    else  
        print("üõë Desync desativado!")  
        removerTabuaEescada()  
    end  
end

end)

RunService.RenderStepped:Connect(function()
if not enabled then return end

local playerTeam = LocalPlayer.Team and LocalPlayer.Team.Name  
local ball = GetBall()  

if not ball then  
	if playerTeam ~= "Playing" then  
		enabled = false  
		removerTabuaEescada()  
		warn("‚ö†Ô∏è Desync desativado automaticamente: Bola real ausente e jogador fora do time 'Playing'.")  
	end  
	-- Se estiver no time Playing, apenas ignora e mant√©m o √∫ltimo estado  
	return  
end  

local minHeightAtual = ball:GetAttribute("minHeight") or ball.Position.Y  
if minHeightAtual ~= ultimoMinHeight then  
	ultimoMinHeight = minHeightAtual  
	moverTabuaEescada(minHeightAtual)  
end  

fakePos = Vector3.new(basePosX, minHeightAtual + dESYNCCENTRALPOSITION, basePosZ)

end)

-- LOOP DE DESYNC √öNICO
RunService.Heartbeat:Connect(function()
if not enabled then return end
local char = LocalPlayer.Character
if not char then return end
local hrp = char:FindFirstChild("HumanoidRootPart")
local humanoid = char:FindFirstChildOfClass("Humanoid")
if not hrp or not humanoid or humanoid.Health <= 0 then return end

-- armazena estado real  
DesyncState.CFrame = hrp.CFrame  
DesyncState.Velocity = hrp.AssemblyLinearVelocity  

-- faz o servidor ‚Äúver‚Äù voc√™ na fakePos com godmode  
local spoofCFrame = CFrame.new(fakePos) * CFrame.Angles(  
    math.rad(RandomNumberRange(180)),  
    math.rad(RandomNumberRange(180)),  
    math.rad(RandomNumberRange(180))  
)  
hrp.CFrame = spoofCFrame  
hrp.AssemblyLinearVelocity = Vector3.new(0, 1, 0) * 17000  

-- aguarda pr√≥ximo frame de renderiza√ß√£o  
RunService.RenderStepped:Wait()  

-- restaura seu estado real para a c√¢mera e f√≠sica  
hrp.CFrame = DesyncState.CFrame  
hrp.AssemblyLinearVelocity = DesyncState.Velocity

end)

-- Spoof da propriedade CFrame
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
if enabled and not checkcaller() and key == "CFrame" then
local char = LocalPlayer.Character
if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
local hrp = char.HumanoidRootPart
if self == hrp then
return DesyncState.CFrame or CFrame.new()
elseif self == char:FindFirstChild("Head") then
return (DesyncState.CFrame or CFrame.new()) * CFrame.new(0, hrp.Size.Y/2 + 0.5, 0)
end
end
end
return oldIndex(self, key)
end))

